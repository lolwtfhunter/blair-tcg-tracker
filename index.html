<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blair TCG Set Tracker</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f1f1f1;
            min-height: 100vh;
            padding-bottom: 40px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }
        
        header {
            text-align: center;
            padding: 30px 10px 25px;
            background: linear-gradient(135deg, #1a1a4e 0%, #2d1b69 30%, #1a3a5c 70%, #162447 100%);
            border-radius: 18px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 215, 0, 0.15);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .header-pokemon-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        /* Pokeball SVG background decorations (subtle/ghosted) */
        .header-pokemon-bg .pokeball-bg {
            position: absolute;
            opacity: 0.08;
        }
        .header-pokemon-bg .pokeball-bg.pb1 {
            left: -15px; top: 50%; transform: translateY(-50%) rotate(-15deg); width: 130px; height: 130px;
        }
        .header-pokemon-bg .pokeball-bg.pb2 {
            right: -20px; bottom: -15px; transform: rotate(20deg); width: 110px; height: 110px;
        }
        .header-pokemon-bg .pokeball-bg.pb3 {
            right: 30%; top: -25px; transform: rotate(10deg); width: 80px; height: 80px;
        }
        .header-pokemon-bg .pokeball-bg.pb4 {
            left: 25%; bottom: -20px; transform: rotate(-25deg); width: 70px; height: 70px; opacity: 0.05;
        }

        /* Real cartoon Pokemon character images */
        .header-pokemon-bg .pokemon-char {
            position: absolute;
            bottom: 5px;
            height: auto;
            z-index: 1;
            filter: drop-shadow(0 2px 10px rgba(0, 0, 0, 0.5));
            transition: transform 0.3s ease;
        }
        .header-pokemon-bg .pokemon-char:hover {
            transform: scale(1.08) translateY(-2px);
        }
        .header-pokemon-bg .pokemon-pikachu {
            right: 8px;
            width: 88px;
        }
        .header-pokemon-bg .pokemon-psyduck {
            left: 8px;
            width: 78px;
        }
        .header-pokemon-bg .pokemon-togepi {
            left: 50%;
            transform: translateX(-50%);
            bottom: -2px;
            width: 62px;
            opacity: 0.9;
        }
        .header-pokemon-bg .pokemon-togepi:hover {
            transform: translateX(-50%) scale(1.08) translateY(-2px);
        }

        /* Pokeball PNG accents (floating) */
        .header-pokemon-bg .pokeball-accent {
            position: absolute;
            z-index: 1;
            opacity: 0.5;
            width: 28px;
        }
        .header-pokemon-bg .pokeball-accent.pba1 {
            top: 8px; left: 18%;
            animation: float-pokeball 4s ease-in-out infinite;
        }
        .header-pokemon-bg .pokeball-accent.pba2 {
            width: 22px; top: 12px; right: 22%;
            animation: float-pokeball 4s ease-in-out infinite 1.5s;
        }

        @keyframes float-pokeball {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-4px) rotate(15deg); }
        }

        /* Floating sparkles */
        .header-sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffd700;
            border-radius: 50%;
            opacity: 0;
            animation: sparkle 3s ease-in-out infinite;
            z-index: 2;
        }
        .header-sparkle:nth-child(1) { left: 20%; top: 20%; animation-delay: 0s; }
        .header-sparkle:nth-child(2) { left: 45%; top: 60%; animation-delay: 0.8s; }
        .header-sparkle:nth-child(3) { left: 70%; top: 25%; animation-delay: 1.6s; }
        .header-sparkle:nth-child(4) { left: 85%; top: 50%; animation-delay: 2.2s; }
        .header-sparkle:nth-child(5) { left: 35%; top: 35%; animation-delay: 1.2s; width: 3px; height: 3px; }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            z-index: 3;
            text-shadow: none;
            font-weight: 800;
            letter-spacing: 0.5px;
        }
        
        .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            position: relative;
            z-index: 3;
        }
        
        .sync-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }
        
        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .sync-indicator.synced { background: #00ff88; }
        .sync-indicator.syncing { background: #ffaa00; animation: pulse 1s infinite; }
        .sync-indicator.error { background: #ff4444; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .set-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .set-btn {
            padding: 12px 15px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #f1f1f1;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            text-align: left;
        }
        
        .set-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }
        
        .set-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        .set-btn-left {
            display: flex;
            flex-direction: column;
        }
        
        .set-btn-name {
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .set-btn .set-release-date {
            font-size: 0.6rem;
            opacity: 0.5;
            margin-top: 2px;
        }
        
        .set-btn .block-badge {
            font-size: 0.55rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 10px;
            border-radius: 8px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .set-btn .block-badge.block-sv {
            background: linear-gradient(135deg, #e74c3c, #8e44ad);
            color: #fff;
        }
        
        .set-btn .block-badge.block-me {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: #fff;
        }
        

        .set-btn .block-badge.block-swsh {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #fff;
        }

        /* Top-level tab bar */
        .top-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 4px;
        }

        .top-tab {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            background: transparent;
            color: rgba(241, 241, 241, 0.5);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .top-tab:hover {
            color: rgba(241, 241, 241, 0.8);
            background: rgba(255, 255, 255, 0.05);
        }

        .top-tab.active {
            background: rgba(255, 255, 255, 0.12);
            color: #f1f1f1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .top-tab-content {
            display: none;
            overflow: hidden;
        }

        .top-tab-content.active {
            display: block;
        }

        .placeholder-content {
            text-align: center;
            padding: 60px 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .placeholder-content h2 {
            font-size: 1.5rem;
            margin-bottom: 12px;
            opacity: 0.9;
        }

        .placeholder-content p {
            font-size: 0.95rem;
            opacity: 0.5;
            line-height: 1.6;
        }

        .placeholder-content .coming-soon-badge {
            display: inline-block;
            padding: 6px 18px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 16px;
        }

        .coming-soon-badge.custom-sets {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
        }

        .coming-soon-badge.lorcana {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: #fff;
        }

        /* Inline progress bar in set buttons */
        .set-btn-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 6px;
        }

        .set-btn-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            transition: width 0.3s;
            border-radius: 4px;
        }

        .set-btn.active .set-btn-progress {
            background: rgba(255, 255, 255, 0.2);
        }

        .set-btn-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            flex-shrink: 0;
        }

        .set-btn-stats {
            font-size: 0.6rem;
            opacity: 0.6;
            white-space: nowrap;
        }

        .set-btn.active .set-btn-stats {
            opacity: 0.85;
        }
        
        .set-section {
            display: none;
        }
        
        .set-section.active {
            display: block;
        }

        /* Card controls: filters and search */
        .card-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
            align-items: center;
        }

        .filter-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: #f1f1f1;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: rgba(102, 126, 234, 0.4);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .search-container {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 8px 36px 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: #f1f1f1;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(102, 126, 234, 0.5);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .search-clear:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        .search-clear.visible {
            display: flex;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 8px;
        }
        
        .card-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 8px;
            transition: all 0.2s;
            font-size: 0.85rem;
            min-width: 0;
            overflow: hidden;
            cursor: pointer;
        }
        
        .card-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        .card-item.all-collected {
            background: rgba(0, 255, 136, 0.08);
            border: 1px solid rgba(0, 255, 136, 0.2);
            opacity: 0.55;
            transition: opacity 0.2s;
        }

        .card-item.all-collected:hover {
            opacity: 0.85;
        }

        .card-item.all-collected .card-img-wrapper img {
            filter: saturate(0.4) brightness(0.85);
            transition: filter 0.2s;
        }

        .card-item.all-collected:hover .card-img-wrapper img {
            filter: saturate(0.7) brightness(0.95);
        }

        /* Lock badge on completed cards */
        .completed-lock {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.6rem;
            color: #00ff88;
            opacity: 0.7;
            margin-top: 4px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .completed-lock svg {
            width: 10px;
            height: 10px;
            fill: #00ff88;
        }

        /* Unlock confirmation toast */
        .unlock-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #16213e;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 14px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 9999;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            transition: transform 0.3s ease;
            max-width: 340px;
            width: calc(100% - 40px);
        }

        .unlock-toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .unlock-toast-text {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.3;
        }

        .unlock-toast-buttons {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .unlock-toast-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .unlock-toast-btn.confirm {
            background: rgba(255, 68, 68, 0.8);
            color: #fff;
        }

        .unlock-toast-btn.confirm:hover {
            background: rgba(255, 68, 68, 1);
        }

        .unlock-toast-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #f1f1f1;
        }

        .unlock-toast-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Card Detail Modal */
        .card-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card-modal.visible {
            display: flex;
            opacity: 1;
        }

        .card-modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .card-modal.visible .card-modal-content {
            transform: scale(1);
        }

        .card-modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #f1f1f1;
            font-size: 1.5rem;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        .card-modal-close:hover {
            background: rgba(255, 68, 68, 0.8);
            transform: rotate(90deg);
        }

        .card-modal-body {
            display: flex;
            gap: 24px;
            padding: 24px;
        }

        .card-modal-image {
            flex-shrink: 0;
            width: 300px;
        }

        .card-modal-image img {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .card-modal-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f1f1f1;
            margin-bottom: 4px;
        }

        .card-modal-number {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 600;
        }

        .card-modal-set {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 4px;
        }

        .card-modal-rarity {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 8px;
        }

        .card-modal-variants {
            margin-top: 8px;
        }

        .card-modal-variants-title {
            font-size: 0.85rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .card-modal-variant-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .card-modal-variant-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
        }

        .card-modal-variant-item.collected {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .card-modal-variant-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Mobile responsive modal */
        @media (max-width: 768px) {
            .card-modal-body {
                flex-direction: column;
                padding: 16px;
            }

            .card-modal-image {
                width: 100%;
                max-width: 280px;
                margin: 0 auto;
            }

            .card-modal-title {
                font-size: 1.2rem;
            }

            .card-modal-close {
                top: 12px;
                right: 12px;
                width: 32px;
                height: 32px;
                font-size: 1.2rem;
            }
        }

        /* Card image support */
        .card-img-wrapper {
            width: 100%;
            aspect-ratio: 3 / 4;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.04);
            position: relative;
        }
        .card-img-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: transform 0.3s ease;
        }
        .card-item:hover .card-img-wrapper img {
            transform: scale(1.03);
        }
        .card-img-wrapper .card-img-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            opacity: 0.3;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .card-header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .card-info {
            flex: 1;
        }

        .tcgplayer-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            background: #2563eb;
            color: white;
            border-radius: 4px;
            text-decoration: none;
            transition: background 0.2s ease;
            flex-shrink: 0;
        }

        .tcgplayer-link:hover {
            background: #1d4ed8;
        }

        .tcgplayer-link svg {
            width: 16px;
            height: 16px;
        }
        
        .card-number {
            font-size: 0.7rem;
            opacity: 0.6;
            margin-bottom: 2px;
        }
        
        .card-name {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 3px;
            line-height: 1.2;
        }
        
        .rarity-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        /* Main set rarities */
        .rarity-common { background: #666; }
        .rarity-uncommon { background: #4a9eff; }
        .rarity-rare { background: #9d4aff; }
        
        /* EX and basic special */
        .rarity-ex { background: #ff6b6b; }
        .rarity-trainer { background: #ff9500; }
        .rarity-energy { background: #48c774; }
        
        /* Secret rare types (all get special styling) */
        .rarity-secret { background: linear-gradient(45deg, #ffd700, #ffed4e); color: #000; }
        .rarity-illustration-rare { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
        }
        .rarity-special-illustration-rare { 
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
        }
        .rarity-ultra-rare {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .rarity-rare-holo-gx {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
        }
        .rarity-hyper-rare { 
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); 
            color: #000;
        }
        .rarity-double-rare { 
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); 
        }
        .rarity-trainer-ultra-rare { 
            background: linear-gradient(135deg, #ff9a56 0%, #ffecd2 100%); 
            color: #000;
        }
        .rarity-gold-secret { 
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%); 
        }
        
        /* Special mechanic rarities */
        .rarity-ace-spec { 
            background: linear-gradient(135deg, #000000 0%, #434343 100%); 
            border: 2px solid #ffd700;
        }
        .rarity-radiant { 
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%); 
            color: #000;
        }
        .rarity-amazing-rare { 
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%); 
        }
        .rarity-shiny-rare { 
            background: linear-gradient(135deg, #c0c0c0 0%, #ffffff 100%); 
            color: #000;
        }
        .rarity-promo {
            background: linear-gradient(135deg, #ff512f 0%, #dd2476 100%);
        }
        .rarity-rare-holo {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
        }
        
        .region-badge {
            display: inline-block;
            background: #e74c3c;
            color: #fff;
            font-size: 0.55rem;
            font-weight: 700;
            padding: 1px 4px;
            border-radius: 3px;
            vertical-align: middle;
            margin-left: 4px;
        }

        /* Language sub-tab toggle for custom sets with mixed EN/JP cards */
        .lang-toggle {
            display: flex;
            gap: 2px;
            margin: 0 auto 12px auto;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 8px;
            padding: 3px;
            width: fit-content;
        }

        .lang-toggle-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: rgba(241, 241, 241, 0.45);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .lang-toggle-btn:hover {
            color: rgba(241, 241, 241, 0.7);
            background: rgba(255, 255, 255, 0.05);
        }

        .lang-toggle-btn.active {
            background: rgba(255, 255, 255, 0.12);
            color: #f1f1f1;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        .lang-toggle-btn .lang-count {
            font-size: 0.65rem;
            opacity: 0.6;
            font-weight: 400;
        }

        .lang-toggle-btn.active .lang-count {
            opacity: 0.8;
        }

        .card-origin {
            font-size: 0.6rem;
            opacity: 0.45;
            padding: 2px 8px 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .variants-section {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 6px;
        }
        
        .variants-title {
            font-size: 0.65rem;
            opacity: 0.5;
            margin-bottom: 4px;
            text-transform: uppercase;
            display: none; /* Hide "VARIANTS:" label to save space */
        }
        
        .variant-checkboxes {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .variant-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .variant-checkbox:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .variant-checkbox.checked {
            background: rgba(0, 255, 136, 0.2);
        }
        
        .variant-checkbox input {
            cursor: pointer;
            width: 14px;
            height: 14px;
        }
        
        .variant-checkbox label {
            font-size: 0.7rem;
            flex: 1;
        }

        .variant-tcgplayer-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            color: #888;
            text-decoration: none;
            transition: all 0.2s;
            border-radius: 3px;
            margin-left: auto;
        }

        .variant-tcgplayer-link:hover {
            color: #4a9eff;
            background: rgba(74, 158, 255, 0.1);
        }

        .variant-tcgplayer-link svg {
            display: block;
        }

        .single-variant {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
        }
        
        .single-variant.checked {
            background: rgba(0, 255, 136, 0.2);
        }
        
        .single-variant input {
            width: 14px;
            height: 14px;
        }
        
        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }
        
        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 100%;
        }
        
        .modal-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: #00ff88;
        }
        
        .modal-text {
            margin-bottom: 20px;
            opacity: 0.9;
            line-height: 1.5;
        }
        
        .modal-input {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #f1f1f1;
            font-size: 1rem;
            margin-bottom: 15px;
        }
        
        .modal-input:focus {
            outline: none;
            border-color: #00ff88;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
        }
        
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .modal-btn.primary {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            color: #000;
        }
        
        .modal-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }
        
        .error-text {
            color: #ff4444;
            font-size: 0.85rem;
            margin-top: 5px;
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 1.3rem; }
            .header-pokemon-bg .pokemon-pikachu { width: 58px; right: 3px; }
            .header-pokemon-bg .pokemon-psyduck { width: 52px; left: 3px; }
            .header-pokemon-bg .pokemon-togepi { width: 42px; }
            .header-pokemon-bg .pokeball-accent { display: none; }
            .card-grid { 
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
            }
            .set-buttons { grid-template-columns: 1fr; }
            .card-item {
                padding: 5px;
                font-size: 0.75rem;
            }
            .card-name {
                font-size: 0.75rem;
            }
            .card-number {
                font-size: 0.65rem;
            }
            .rarity-badge {
                font-size: 0.55rem;
                padding: 1px 4px;
            }
            .variant-checkbox {
                padding: 2px 4px;
                font-size: 0.65rem;
            }
            .variant-checkbox label {
                font-size: 0.6rem;
            }
            .variant-checkbox input {
                width: 12px;
                height: 12px;
            }
            .card-controls {
                flex-direction: column;
                gap: 8px;
            }
            .filter-buttons {
                width: 100%;
                justify-content: center;
            }
            .filter-btn {
                padding: 6px 12px;
                font-size: 0.75rem;
            }
            .search-container {
                max-width: 100%;
            }
            .search-input {
                font-size: 0.8rem;
                padding: 6px 32px 6px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sync-status">
            <div class="sync-indicator" id="syncIndicator"></div>
            <span id="syncStatus">Offline</span>
        </div>
        
        <header>
            <div class="header-pokemon-bg">
                <!-- Pokeball SVG background decorations (subtle/ghosted) -->
                <svg class="pokeball-bg pb1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="48" fill="none" stroke="#fff" stroke-width="3"/>
                    <path d="M2 50 H98" stroke="#fff" stroke-width="3"/>
                    <circle cx="50" cy="50" r="12" fill="none" stroke="#fff" stroke-width="3"/>
                    <path d="M50 2 A48 48 0 0 1 98 50 H62 A12 12 0 0 0 38 50 H2 A48 48 0 0 1 50 2Z" fill="#fff" opacity="0.3"/>
                </svg>
                <svg class="pokeball-bg pb2" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="48" fill="none" stroke="#fff" stroke-width="3"/>
                    <path d="M2 50 H98" stroke="#fff" stroke-width="3"/>
                    <circle cx="50" cy="50" r="12" fill="none" stroke="#fff" stroke-width="3"/>
                    <path d="M50 2 A48 48 0 0 1 98 50 H62 A12 12 0 0 0 38 50 H2 A48 48 0 0 1 50 2Z" fill="#fff" opacity="0.3"/>
                </svg>
                <svg class="pokeball-bg pb3" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="48" fill="none" stroke="#fff" stroke-width="2"/>
                    <path d="M2 50 H98" stroke="#fff" stroke-width="2"/>
                    <circle cx="50" cy="50" r="10" fill="none" stroke="#fff" stroke-width="2"/>
                </svg>
                <svg class="pokeball-bg pb4" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="48" fill="none" stroke="#fff" stroke-width="2"/>
                    <path d="M2 50 H98" stroke="#fff" stroke-width="2"/>
                    <circle cx="50" cy="50" r="10" fill="none" stroke="#fff" stroke-width="2"/>
                </svg>

                <!-- Real Pokeball PNG accents (floating) -->
                <img class="pokeball-accent pba1" src="Images/header/pokeball.png" alt="">
                <img class="pokeball-accent pba2" src="Images/header/pokeball.png" alt="">

                <!-- Real cartoon Pokemon characters -->
                <img class="pokemon-char pokemon-pikachu" src="Images/header/pikachu.png" alt="Pikachu">
                <img class="pokemon-char pokemon-psyduck" src="Images/header/psyduck.png" alt="Psyduck">
                <img class="pokemon-char pokemon-togepi" src="Images/header/togepi.png" alt="Togepi">

                <!-- Sparkles -->
                <div class="header-sparkle"></div>
                <div class="header-sparkle"></div>
                <div class="header-sparkle"></div>
                <div class="header-sparkle"></div>
                <div class="header-sparkle"></div>
            </div>
            <h1>⚡ Blair TCG Set Tracker ⚡</h1>
            <p class="subtitle">Track your Pokemon, custom sets, and Disney Lorcana collections</p>
        </header>
        
        <!-- Top-level tab navigation -->
        <div class="top-tabs">
            <button class="top-tab active" onclick="switchTopTab('pokemon-tcg')">Pokemon</button>
            <button class="top-tab" onclick="switchTopTab('custom-sets')">Custom Sets</button>
            <button class="top-tab" onclick="switchTopTab('lorcana')">Disney Lorcana</button>
        </div>

        <!-- Pokemon TCG tab content -->
        <div id="pokemon-tcg-content" class="top-tab-content active">
            <div class="set-buttons" id="setButtons"></div>

            <div id="celebrations" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('celebrations', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('celebrations', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('celebrations', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('celebrations', this.value)" data-set="celebrations">
                        <button class="search-clear" onclick="clearSearch('celebrations')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="celebrations-grid"></div>
            </div>

            <div id="surging-sparks" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('surging-sparks', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('surging-sparks', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('surging-sparks', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('surging-sparks', this.value)" data-set="surging-sparks">
                        <button class="search-clear" onclick="clearSearch('surging-sparks')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="surging-sparks-grid"></div>
            </div>

            <div id="prismatic-evolutions" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('prismatic-evolutions', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('prismatic-evolutions', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('prismatic-evolutions', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('prismatic-evolutions', this.value)" data-set="prismatic-evolutions">
                        <button class="search-clear" onclick="clearSearch('prismatic-evolutions')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="prismatic-evolutions-grid"></div>
            </div>

            <div id="journey-together" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('journey-together', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('journey-together', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('journey-together', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('journey-together', this.value)" data-set="journey-together">
                        <button class="search-clear" onclick="clearSearch('journey-together')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="journey-together-grid"></div>
            </div>

            <div id="destined-rivals" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('destined-rivals', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('destined-rivals', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('destined-rivals', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('destined-rivals', this.value)" data-set="destined-rivals">
                        <button class="search-clear" onclick="clearSearch('destined-rivals')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="destined-rivals-grid"></div>
            </div>

            <div id="phantasmal-flames" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('phantasmal-flames', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('phantasmal-flames', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('phantasmal-flames', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('phantasmal-flames', this.value)" data-set="phantasmal-flames">
                        <button class="search-clear" onclick="clearSearch('phantasmal-flames')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="phantasmal-flames-grid"></div>
            </div>

            <div id="ascended-heroes" class="set-section">
                <div class="card-controls">
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterCards('ascended-heroes', 'all')">All</button>
                        <button class="filter-btn" onclick="filterCards('ascended-heroes', 'incomplete')">Incomplete</button>
                        <button class="filter-btn" onclick="filterCards('ascended-heroes', 'complete')">Complete</button>
                    </div>
                    <div class="search-container">
                        <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('ascended-heroes', this.value)" data-set="ascended-heroes">
                        <button class="search-clear" onclick="clearSearch('ascended-heroes')">×</button>
                    </div>
                </div>
                <div class="card-grid" id="ascended-heroes-grid"></div>
            </div>
        </div>

        <!-- Custom Sets tab content -->
        <div id="custom-sets-content" class="top-tab-content">
            <div class="set-buttons" id="customSetButtons"></div>
            <div id="custom-sets-grids"></div>
        </div>

        <!-- Lorcana tab content -->
        <div id="lorcana-content" class="top-tab-content">
            <div class="placeholder-content">
                <h2>Disney Lorcana</h2>
                <p>Disney Lorcana card tracking will be available here.<br>Stay tuned for future updates!</p>
                <span class="coming-soon-badge lorcana">Coming Soon</span>
            </div>
        </div>

    </div>

    <script>
        // Global state
        let cardSets = {};
        let customCardSets = {};
        let collectionProgress = {};
        let currentSet = null; // No set selected by default
        let currentCustomSet = null;
        let customSetLangFilter = {}; // Per-set language filter: 'EN' or 'JP'
        let firebase_db = null;
        let firebase_ref = null;
        
        const SYNC_CODE = 'Blair2024';
        const SYNC_CODE_KEY = 'blair_sync_code';

        // Pokemon TCG API set ID mapping (for card images from pokemontcg.io CDN)
        const TCG_API_SET_IDS = {
            'prismatic-evolutions': 'sv8pt5',
            'journey-together': 'sv9',
            'destined-rivals': 'sv10',
            'phantasmal-flames': 'me2',
            'ascended-heroes': 'me2pt5',
            'celebrations': 'cel25',
            'surging-sparks': 'sv8'
        };

        // TCGdex API set mapping: { series, setId } (for assets.tcgdex.net CDN)
        const TCGDEX_SET_IDS = {
            'prismatic-evolutions': { series: 'sv', set: 'sv08.5' },
            'journey-together':     { series: 'sv', set: 'sv09' },
            'destined-rivals':      { series: 'sv', set: 'sv10' },
            'phantasmal-flames':    { series: 'me', set: 'me02' },
            'ascended-heroes':      { series: 'me', set: 'me02.5' },
            'celebrations':         { series: 'swsh', set: 'cel25' },
            'surging-sparks':       { series: 'sv', set: 'sv08' }
        };

        // Get card image URL from Pokemon TCG API (pokemontcg.io)
        function getCardImageUrl(setKey, cardNumber, imageId) {
            // Celebrations Classic Collection cards use cel25c with original set numbering
            if (setKey === 'celebrations' && imageId) {
                return `https://images.pokemontcg.io/cel25c/${imageId}.png`;
            }
            const apiSetId = TCG_API_SET_IDS[setKey];
            if (apiSetId) {
                return `https://images.pokemontcg.io/${apiSetId}/${cardNumber}.png`;
            }
            return null;
        }

        // Get card image URL from TCGdex API (assets.tcgdex.net)
        function getTcgdexImageUrl(setKey, cardNumber, imageId) {
            // Celebrations Classic Collection uses cel25c with original numbering
            if (setKey === 'celebrations' && imageId) {
                return `https://assets.tcgdex.net/en/swsh/cel25c/${imageId}/high.png`;
            }
            const info = TCGDEX_SET_IDS[setKey];
            if (info) {
                return `https://assets.tcgdex.net/en/${info.series}/${info.set}/${cardNumber}/high.png`;
            }
            return null;
        }

        // Get TCGPlayer URL for a card with enhanced search parameters
        function getTCGPlayerUrl(cardName, setName, setCode, cardNumber, variantType) {
            // Clean up the card name and set name for better search results
            const cleanCardName = cardName.trim();
            const cleanSetName = setName.trim();

            // Build search query with card name, number, and set name
            // Note: Variant types (Holo/Reverse Holo) are not included in search
            // because TCGPlayer has filters for these within the card details page
            let searchQuery = cleanCardName;

            // Add card number if provided (format: "123/456" or just "123")
            if (cardNumber) {
                searchQuery += ` ${cardNumber}`;
            }

            // Add set name
            searchQuery += ` ${cleanSetName}`;

            const encodedQuery = encodeURIComponent(searchQuery);

            // TCGPlayer search URL format with specific parameters
            return `https://www.tcgplayer.com/search/pokemon/product?q=${encodedQuery}&page=1`;
        }

        // Handle card image load errors with cascading fallback:
        // 1. pokemontcg.io CDN -> 2. TCGdex CDN -> 3. Local image -> 4. Placeholder
        function handleImgError(img) {
            const tcgdexSrc = img.getAttribute('data-tcgdex-src');
            const localSrc = img.getAttribute('data-local-src');

            if (tcgdexSrc && img.src.indexOf('images.pokemontcg.io') !== -1) {
                // pokemontcg.io failed, try TCGdex
                img.onerror = function() {
                    // TCGdex also failed, try local
                    if (localSrc) {
                        img.onerror = function() {
                            // All sources failed, show placeholder
                            showPlaceholder(img);
                        };
                        img.src = localSrc;
                    } else {
                        showPlaceholder(img);
                    }
                };
                img.src = tcgdexSrc;
            } else if (localSrc && img.src.indexOf('assets.tcgdex.net') !== -1) {
                // TCGdex failed, try local
                img.onerror = function() {
                    showPlaceholder(img);
                };
                img.src = localSrc;
            } else {
                // Local or unknown source failed, show placeholder
                showPlaceholder(img);
            }
        }

        function showPlaceholder(img) {
            const name = img.getAttribute('data-card-name');
            const number = img.getAttribute('data-card-number');
            const rarity = img.getAttribute('data-card-rarity');
            img.parentElement.innerHTML = generatePlaceholder(name, number, rarity);
        }

        // Generate a styled placeholder when no card image is available
        function generatePlaceholder(name, number, rarity) {
            const num = String(number).padStart(3, '0');
            const colors = {
                'common': '#888',
                'uncommon': '#4a9eff',
                'rare': '#9d4aff',
                'ex': '#ff6b6b',
                'illustration-rare': '#764ba2',
                'special-illustration-rare': '#f5576c',
                'ultra-rare': '#00f2fe',
                'hyper-rare': '#fee140',
                'double-rare': '#fed6e3',
                'secret': '#ffd700',
                'ace-spec': '#ffd700',
                'trainer': '#ff9500',
                'energy': '#48c774'
            };
            const color = colors[rarity] || '#888';
            const escapedName = name.replace(/'/g, '&#39;').replace(/"/g, '&quot;');
            return `<div class="card-img-placeholder" style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;width:100%;height:100%;background:rgba(255,255,255,0.03);border:1px dashed rgba(255,255,255,0.15);border-radius:6px;">
                <svg width="32" height="32" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="opacity:0.4">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="${color}" stroke-width="4"/>
                    <path d="M5 50 H95" stroke="${color}" stroke-width="4"/>
                    <circle cx="50" cy="50" r="12" fill="none" stroke="${color}" stroke-width="4"/>
                </svg>
                <span style="font-size:0.7rem;opacity:0.5;font-weight:600">#${num}</span>
                <span style="font-size:0.55rem;opacity:0.3;text-align:center;padding:0 4px;line-height:1.2">${escapedName}</span>
            </div>`;
        }

        // Variant configurations
        const variantLabels = {
            'single': { label: 'Collected', icon: '✓' },
            'regular': { label: 'Regular', icon: '⚪' },
            'holo': { label: 'Holo', icon: '💎' },
            'reverse-holo': { label: 'Reverse Holo', icon: '✨' },
            'pokeball': { label: 'Poké Ball', icon: '⚾' },
            'masterball': { label: 'Master Ball', icon: '🔮' }
        };
        
        // All possible rarities in Pokemon TCG (future-proof)
        const SINGLE_VARIANT_RARITIES = [
            'ex', 'secret', 'illustration-rare', 'special-illustration-rare',
            'ultra-rare', 'hyper-rare', 'double-rare', 'ace-spec',
            'radiant', 'amazing-rare', 'shiny-rare', 'trainer-ultra-rare',
            'gold-secret', 'promo'
        ];
        
        // Rarity display names
        const RARITY_DISPLAY_NAMES = {
            'common': 'COMMON',
            'uncommon': 'UNCOMMON',
            'rare': 'RARE',
            'ex': 'EX',
            'secret': 'SECRET',
            'illustration-rare': 'ILLUS RARE',
            'special-illustration-rare': 'SPECIAL IR',
            'ultra-rare': 'ULTRA RARE',
            'hyper-rare': 'HYPER RARE',
            'double-rare': 'DOUBLE RARE',
            'trainer-ultra-rare': 'TRAINER UR',
            'gold-secret': 'GOLD',
            'ace-spec': 'ACE SPEC',
            'radiant': 'RADIANT',
            'amazing-rare': 'AMAZING',
            'shiny-rare': 'SHINY',
            'promo': 'PROMO',
            'rare-holo': 'RARE HOLO',
            'rare-holo-gx': 'HOLO GX',
            'trainer': 'TRAINER',
            'energy': 'ENERGY'
        };
        
        // Get display name for rarity
        function getRarityDisplay(rarity) {
            return RARITY_DISPLAY_NAMES[rarity] || rarity.toUpperCase();
        }
        
        // Determine variants for a card
        function getVariants(card, setKey) {
            const setData = cardSets[setKey];
            const rarity = card.rarity.toLowerCase();

            // Sets where all cards are single variant (e.g., Celebrations)
            if (setData && setData.singleVariantOnly) {
                return ['single'];
            }

            // Single checkbox rarities (EX, Ultra Rares, Illustration Rares, etc.)
            if (SINGLE_VARIANT_RARITIES.includes(rarity)) {
                return ['single'];
            }
            
            // Rare cards get Holo + Reverse Holo (no regular)
            if (rarity === 'rare') {
                // Special case: Prismatic Evolutions rares get extra variants
                if (setKey === 'prismatic-evolutions' && card.type !== 'trainer') {
                    return ['holo', 'reverse-holo', 'pokeball', 'masterball'];
                }
                return ['holo', 'reverse-holo'];
            }
            
            // Prismatic Evolutions special variants for commons/uncommons
            if (setKey === 'prismatic-evolutions') {
                if (card.type === 'trainer') {
                    return ['regular', 'reverse-holo', 'pokeball'];
                }
                // Regular pokemon get all 4 variants
                return ['regular', 'reverse-holo', 'pokeball', 'masterball'];
            }
            
            // All other cards (common, uncommon, trainer, energy): Regular + Reverse Holo
            return ['regular', 'reverse-holo'];
        }
        
        // Load card data from JSON
        async function loadCardData() {
            console.log('Loading card-data.json...');
            try {
                const response = await fetch('./card-data.json');
                const data = await response.json();
                
                console.log(`JSON loaded: ${Object.keys(data.sets).length} sets`);
                
                // Build cardSets from JSON - NEW structure with card objects
                for (const [setKey, setInfo] of Object.entries(data.sets)) {
                    const cards = [];
                    
                    // Convert cards object to array
                    if (setInfo.cards && typeof setInfo.cards === 'object') {
                        for (const [cardNum, cardData] of Object.entries(setInfo.cards)) {
                            const cardObj = {
                                number: parseInt(cardNum),
                                name: cardData.name,
                                rarity: cardData.rarity,
                                type: cardData.type || 'pokemon'
                            };
                            if (cardData.imageId) cardObj.imageId = cardData.imageId;
                            cards.push(cardObj);
                        }
                    }
                    
                    cardSets[setKey] = {
                        name: setInfo.name,
                        displayName: setInfo.displayName,
                        totalCards: setInfo.totalCards,
                        mainSet: setInfo.mainSet,
                        setCode: setInfo.setCode,
                        releaseDate: setInfo.releaseDate || '',
                        block: setInfo.block || '',
                        blockCode: setInfo.blockCode || '',
                        hasPokeBallVariant: setInfo.hasPokeBallVariant,
                        hasMasterBallVariant: setInfo.hasMasterBallVariant,
                        singleVariantOnly: setInfo.singleVariantOnly || false,
                        cards: cards
                    };
                    
                    console.log(`${setKey}: ${cards.length} cards`);
                }
                
                console.log('✓ Card data loaded');
                return true;
            } catch (error) {
                console.log('ERROR: ' + error.message);
                console.error('Error loading card data:', error);
                alert('Failed to load card data. Please refresh the page.');
                return false;
            }
        }
        
        // Load custom sets data from JSON
        async function loadCustomSetsData() {
            console.log('Loading custom-sets-data.json...');
            try {
                const response = await fetch('./custom-sets-data.json');
                if (!response.ok) {
                    console.log('No custom-sets-data.json found, skipping');
                    return true;
                }
                const data = await response.json();

                console.log(`Custom sets JSON loaded: ${Object.keys(data.customSets).length} sets`);

                for (const [setKey, setInfo] of Object.entries(data.customSets)) {
                    const cards = [];

                    if (setInfo.cards && typeof setInfo.cards === 'object') {
                        for (const [cardNum, cardData] of Object.entries(setInfo.cards)) {
                            const cardObj = {
                                number: parseInt(cardNum),
                                name: cardData.name,
                                rarity: cardData.rarity,
                                type: cardData.type || 'pokemon',
                                setOrigin: cardData.setOrigin || '',
                                apiId: cardData.apiId || '',
                                releaseDate: cardData.releaseDate || '',
                                originalNumber: cardData.originalNumber || '',
                                region: cardData.region || ''
                            };
                            // Parse variants array if present (merged cards with multiple rarities)
                            if (cardData.variants && Array.isArray(cardData.variants)) {
                                cardObj.variants = cardData.variants;
                            }
                            cards.push(cardObj);
                        }
                    }

                    customCardSets[setKey] = {
                        name: setInfo.name,
                        displayName: setInfo.displayName,
                        description: setInfo.description || '',
                        totalCards: setInfo.totalCards,
                        singleVariantOnly: setInfo.singleVariantOnly !== false,
                        cards: cards
                    };

                    console.log(`Custom set ${setKey}: ${cards.length} cards`);
                }

                console.log('✓ Custom sets data loaded');
                return true;
            } catch (error) {
                console.log('Custom sets load error: ' + error.message);
                return true; // Non-fatal, app continues without custom sets
            }
        }

        // Get image URL for a custom set card using its apiId
        function getCustomCardImageUrl(card) {
            if (card.apiId) {
                // apiId format is "setId-number", e.g. "base1-58"
                const parts = card.apiId.split('-');
                const setId = parts.slice(0, -1).join('-');
                const num = parts[parts.length - 1];
                return `https://images.pokemontcg.io/${setId}/${num}.png`;
            }
            return null;
        }

        // Render custom set buttons
        function renderCustomSetButtons() {
            const container = document.getElementById('customSetButtons');
            if (!container) return;
            container.innerHTML = '';

            const setKeys = Object.keys(customCardSets);
            if (setKeys.length === 0) return;

            // Default to first custom set if none selected
            if (!currentCustomSet) currentCustomSet = setKeys[0];

            setKeys.forEach(setKey => {
                const setData = customCardSets[setKey];
                const btn = document.createElement('button');
                btn.className = 'set-btn' + (setKey === currentCustomSet ? ' active' : '');
                btn.setAttribute('data-custom-set-key', setKey);

                const progress = getCustomSetProgress(setKey);

                btn.innerHTML = `
                    <div class="set-btn-left" style="flex:1;min-width:0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <span class="set-btn-name">${setData.displayName}</span>
                            <div class="set-btn-right">
                                <span class="set-btn-stats">${progress.collected}/${progress.total} (${progress.percentage}%)</span>
                            </div>
                        </div>
                        <span class="set-release-date">${setData.totalCards} cards</span>
                        <div class="set-btn-progress">
                            <div class="set-btn-progress-fill" style="width: ${progress.percentage}%"></div>
                        </div>
                    </div>
                `;
                btn.onclick = () => switchCustomSet(setKey);
                container.appendChild(btn);
            });
        }

        // Switch custom set
        function switchCustomSet(setKey) {
            currentCustomSet = setKey;

            document.querySelectorAll('#customSetButtons .set-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-custom-set-key') === setKey);
            });

            document.querySelectorAll('#custom-sets-grids .set-section').forEach(section => {
                section.classList.remove('active');
            });
            const target = document.getElementById('custom-' + setKey);
            if (target) target.classList.add('active');

            // Render cards if not already rendered
            const grid = document.getElementById('custom-' + setKey + '-grid');
            if (grid && grid.children.length === 0) {
                renderCustomCards(setKey);
            }
        }

        // Calculate progress for a custom set (respects language filter if set has mixed regions)
        function getCustomSetProgress(setKey) {
            const setData = customCardSets[setKey];
            const csKey = 'custom-' + setKey;
            let totalVariants = 0;
            let collectedVariants = 0;

            if (setData && setData.cards) {
                const hasMixed = customSetHasRegions(setKey);
                const lang = getLangFilter(setKey);

                setData.cards.forEach(card => {
                    // If mixed, only count cards for the active language filter
                    if (hasMixed) {
                        const isJP = card.region === 'JP';
                        if (lang === 'JP' && !isJP) return;
                        if (lang === 'EN' && isJP) return;
                    }
                    const variants = getCustomCardVariants(card);
                    totalVariants += variants.length;
                    const cardProgress = (collectionProgress[csKey] || {})[card.number] || {};
                    variants.forEach(v => {
                        if (cardProgress[v]) collectedVariants++;
                    });
                });
            }

            const percentage = totalVariants > 0 ? (collectedVariants / totalVariants * 100).toFixed(1) : '0.0';
            return { collected: collectedVariants, total: totalVariants, percentage };
        }

        // Update custom set button progress
        function updateCustomSetButtonProgress() {
            document.querySelectorAll('#customSetButtons .set-btn[data-custom-set-key]').forEach(btn => {
                const setKey = btn.getAttribute('data-custom-set-key');
                const progress = getCustomSetProgress(setKey);
                const fill = btn.querySelector('.set-btn-progress-fill');
                const stats = btn.querySelector('.set-btn-stats');
                if (fill) fill.style.width = progress.percentage + '%';
                if (stats) stats.textContent = `${progress.collected}/${progress.total} (${progress.percentage}%)`;
            });
        }

        // Get variant keys for a custom card
        function getCustomCardVariants(card) {
            // Explicit variant arrays (WotC holo/non-holo pairs) take priority
            if (card.variants && card.variants.length > 0) {
                return card.variants.map(v => v.rarity);
            }

            const rarity = card.rarity.toLowerCase();

            // Japanese exclusive cards → single
            if (card.region === 'JP') {
                return ['single'];
            }

            // Single-variant rarities (promos, ultra rares, illustration rares, etc.)
            if (SINGLE_VARIANT_RARITIES.includes(rarity)) {
                return ['single'];
            }

            // Inherently holo rarities → single (non-holo versions are separate entries)
            if (rarity === 'rare-holo' || rarity === 'rare-holo-gx') {
                return ['single'];
            }

            // Energy cards → single
            if (rarity === 'energy') {
                return ['single'];
            }

            // Pre-reverse-holo era (before Expedition Base Set, June 2002)
            if (card.releaseDate && card.releaseDate < '2002/06') {
                return ['single'];
            }

            // Special sets/products that don't have reverse holos
            const setOrigin = (card.setOrigin || '').toLowerCase();
            if (setOrigin.includes('mcdonald') ||
                setOrigin.includes('southern islands') ||
                setOrigin.includes('pop series') ||
                setOrigin.includes('best of') ||
                setOrigin.includes('celebrations') ||
                setOrigin.includes('black star')) {
                return ['single'];
            }

            // Rare → holo + reverse-holo
            if (rarity === 'rare') {
                return ['holo', 'reverse-holo'];
            }

            // Common/Uncommon/Trainer → regular + reverse-holo
            return ['regular', 'reverse-holo'];
        }

        // Get image URL for a specific variant of a custom card
        function getCustomVariantImageUrl(card, variantKey) {
            if (card.variants) {
                const variant = card.variants.find(v => v.rarity === variantKey);
                if (variant && variant.apiId) {
                    const parts = variant.apiId.split('-');
                    const setId = parts.slice(0, -1).join('-');
                    const num = parts[parts.length - 1];
                    return `https://images.pokemontcg.io/${setId}/${num}.png`;
                }
            }
            return getCustomCardImageUrl(card);
        }

        // Render cards for a custom set
        function renderCustomCards(setKey) {
            const csKey = 'custom-' + setKey;
            const grid = document.getElementById(csKey + '-grid');
            const setData = customCardSets[setKey];

            if (!grid || !setData) return;

            grid.innerHTML = '';

            if (!collectionProgress[csKey]) {
                collectionProgress[csKey] = {};
            }

            // Filter cards by language if the set has mixed regions
            const hasMixed = customSetHasRegions(setKey);
            const lang = getLangFilter(setKey);
            const filteredCards = hasMixed
                ? setData.cards.filter(card => lang === 'JP' ? card.region === 'JP' : card.region !== 'JP')
                : setData.cards;

            filteredCards.forEach(card => {
                const cardProgress = collectionProgress[csKey][card.number] || {};
                const variants = getCustomCardVariants(card);
                const hasMultiVariants = variants.length > 1;
                const allCollected = variants.every(v => cardProgress[v]);
                const isSingleVariant = !hasMultiVariants;

                const cardEl = document.createElement('div');
                cardEl.className = 'card-item' + (allCollected ? ' all-collected' : '');
                cardEl.setAttribute('data-completed', allCollected ? 'true' : 'false');
                cardEl.style.cursor = 'pointer';
                cardEl.onclick = function(e) {
                    // Don't open modal if clicking on checkboxes or their containers
                    if (e.target.tagName === 'INPUT' ||
                        e.target.tagName === 'LABEL' ||
                        e.target.closest('.variant-checkbox') ||
                        e.target.closest('.single-variant')) {
                        return;
                    }
                    openCardModal(csKey, card.number);
                };

                const rarityClass = `rarity-${card.rarity}`;

                // Build variant HTML
                let variantHTML = '';
                if (hasMultiVariants) {
                    if (card.variants && card.variants.length > 1) {
                        // Explicit variant data (WotC holo/non-holo pairs)
                        const customCardNumber = card.originalNumber || null;
                        variantHTML = card.variants.map(v => {
                            const isChecked = cardProgress[v.rarity] || false;
                            const displayNum = v.originalNumber ? ` #${v.originalNumber}` : '';
                            const variantTCGUrl = getTCGPlayerUrl(card.name, card.setOrigin || 'Pokemon', '', v.originalNumber || customCardNumber);
                            return `
                                <div class="variant-checkbox ${isChecked ? 'checked' : ''}" onclick="toggleVariant('${csKey}', ${card.number}, '${v.rarity}')">
                                    <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="event.stopPropagation(); toggleVariant('${csKey}', ${card.number}, '${v.rarity}')">
                                    <label>${getRarityDisplay(v.rarity)}${displayNum}</label>
                                    <a href="${variantTCGUrl}" target="_blank" class="variant-tcgplayer-link" title="Search on TCGPlayer" onclick="event.stopPropagation();">
                                        <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor">
                                            <path d="M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                                        </svg>
                                    </a>
                                </div>
                            `;
                        }).join('');
                    } else {
                        // Computed variants (regular + reverse-holo, holo + reverse-holo, etc.)
                        const customCardNumber = card.originalNumber || null;
                        variantHTML = variants.map(variant => {
                            const isChecked = cardProgress[variant] || false;
                            const info = variantLabels[variant];
                            const variantTCGUrl = getTCGPlayerUrl(card.name, card.setOrigin || 'Pokemon', '', customCardNumber, variant);
                            return `
                                <div class="variant-checkbox ${isChecked ? 'checked' : ''}" onclick="toggleVariant('${csKey}', ${card.number}, '${variant}')">
                                    <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="event.stopPropagation(); toggleVariant('${csKey}', ${card.number}, '${variant}')">
                                    <label>${info.icon} ${info.label}</label>
                                    <a href="${variantTCGUrl}" target="_blank" class="variant-tcgplayer-link" title="Search ${info.label} on TCGPlayer" onclick="event.stopPropagation();">
                                        <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor">
                                            <path d="M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                                        </svg>
                                    </a>
                                </div>
                            `;
                        }).join('');
                    }
                    variantHTML = '<div class="variant-checkboxes">' + variantHTML + '</div>';
                } else {
                    const isChecked = cardProgress['single'] || false;
                    variantHTML = `
                        <div class="single-variant ${isChecked ? 'checked' : ''}" onclick="toggleVariant('${csKey}', ${card.number}, 'single')">
                            <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="event.stopPropagation(); toggleVariant('${csKey}', ${card.number}, 'single')">
                            <label>✓ Collected</label>
                        </div>
                    `;
                }

                const imgUrl = getCustomCardImageUrl(card);
                const placeholderFallback = `onerror="showPlaceholder(this)"`;

                // Display originalNumber from the set instead of the sequential custom set number
                const displayNumber = card.originalNumber ? card.originalNumber : String(card.number).padStart(3, '0');

                // Generate TCGPlayer URL for custom cards using the setOrigin
                const customCardNumber = card.originalNumber || null;
                const tcgplayerUrl = getTCGPlayerUrl(card.name, card.setOrigin || 'Pokemon', '', customCardNumber);

                cardEl.innerHTML = `
                    <div class="card-img-wrapper">
                        <img src="${imgUrl || ''}"
                             alt="${card.name.replace(/"/g, '&quot;')}"
                             loading="lazy"
                             data-card-name="${card.name.replace(/"/g, '&quot;')}"
                             data-card-number="${displayNumber}"
                             data-card-rarity="${card.rarity}"
                             ${placeholderFallback}>
                    </div>
                    <div class="card-header">
                        <div class="card-info">
                            <div class="card-number">#${displayNumber}${card.region === 'JP' ? ' <span class="region-badge">JP</span>' : ''}</div>
                            <div class="card-name">${card.name}</div>
                            <span class="rarity-badge ${rarityClass}">${getRarityDisplay(card.rarity)}</span>
                        </div>
                        <a href="${tcgplayerUrl}" target="_blank" class="tcgplayer-link" title="View on TCGPlayer" onclick="event.stopPropagation();">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                <path d="M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                            </svg>
                        </a>
                    </div>
                    <div class="card-origin">${card.setOrigin}</div>
                    <div class="variants-section">
                        <div class="variants-title">${isSingleVariant ? 'STATUS:' : 'VARIANTS:'}</div>
                        ${variantHTML}
                        ${allCollected ? `<div class="completed-lock"><svg viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2z"/></svg>Complete</div>` : ''}
                    </div>
                `;

                grid.appendChild(cardEl);
            });

            // Reapply active filters and search after rendering
            applyFiltersAndSearch(csKey);
        }

        // Check if a custom set has mixed EN/JP cards
        function customSetHasRegions(setKey) {
            const setData = customCardSets[setKey];
            if (!setData) return false;
            let hasEN = false, hasJP = false;
            for (const card of setData.cards) {
                if (card.region === 'JP') hasJP = true;
                else hasEN = true;
                if (hasEN && hasJP) return true;
            }
            return false;
        }

        // Get card counts per language for a custom set
        function customSetRegionCounts(setKey) {
            const setData = customCardSets[setKey];
            if (!setData) return { en: 0, jp: 0 };
            let en = 0, jp = 0;
            setData.cards.forEach(card => {
                if (card.region === 'JP') jp++;
                else en++;
            });
            return { en, jp };
        }

        // Get current language filter for a custom set
        function getLangFilter(setKey) {
            return customSetLangFilter[setKey] || 'EN';
        }

        // Switch language filter for a custom set
        function switchLangFilter(setKey, lang) {
            customSetLangFilter[setKey] = lang;
            renderCustomCards(setKey);
            updateLangToggleUI(setKey);
            updateCustomSetButtonProgress();
        }

        // Update language toggle button active states
        function updateLangToggleUI(setKey) {
            const container = document.getElementById('custom-' + setKey + '-lang-toggle');
            if (!container) return;
            const lang = getLangFilter(setKey);
            container.querySelectorAll('.lang-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-lang') === lang);
            });
        }

        // Create DOM elements for custom set grids
        function initCustomSetGrids() {
            const container = document.getElementById('custom-sets-grids');
            if (!container) return;
            container.innerHTML = '';

            Object.keys(customCardSets).forEach((setKey, idx) => {
                const section = document.createElement('div');
                section.id = 'custom-' + setKey;
                section.className = 'set-section' + (setKey === currentCustomSet ? ' active' : '');

                let langToggleHTML = '';
                if (customSetHasRegions(setKey)) {
                    const counts = customSetRegionCounts(setKey);
                    const lang = getLangFilter(setKey);
                    langToggleHTML = `
                        <div class="lang-toggle" id="custom-${setKey}-lang-toggle">
                            <button class="lang-toggle-btn ${lang === 'EN' ? 'active' : ''}" data-lang="EN" onclick="switchLangFilter('${setKey}', 'EN')">English <span class="lang-count">${counts.en}</span></button>
                            <button class="lang-toggle-btn ${lang === 'JP' ? 'active' : ''}" data-lang="JP" onclick="switchLangFilter('${setKey}', 'JP')">Japanese <span class="lang-count">${counts.jp}</span></button>
                        </div>
                    `;
                }

                const controlsHTML = `
                    <div class="card-controls">
                        <div class="filter-buttons">
                            <button class="filter-btn active" onclick="filterCards('custom-${setKey}', 'all')">All</button>
                            <button class="filter-btn" onclick="filterCards('custom-${setKey}', 'incomplete')">Incomplete</button>
                            <button class="filter-btn" onclick="filterCards('custom-${setKey}', 'complete')">Complete</button>
                        </div>
                        <div class="search-container">
                            <input type="text" class="search-input" placeholder="Search cards..." oninput="searchCards('custom-${setKey}', this.value)" data-set="custom-${setKey}">
                            <button class="search-clear" onclick="clearSearch('custom-${setKey}')">×</button>
                        </div>
                    </div>
                `;

                section.innerHTML = langToggleHTML + controlsHTML + `<div class="card-grid" id="custom-${setKey}-grid"></div>`;
                container.appendChild(section);
            });
        }

        // Initialize collection progress
        function initializeProgress() {
            const saved = localStorage.getItem('pokemonVariantProgress');
            if (saved) {
                collectionProgress = JSON.parse(saved);
            } else {
                collectionProgress = {};
                Object.keys(cardSets).forEach(setKey => {
                    collectionProgress[setKey] = {};
                });
            }
            // Also ensure custom set keys exist in progress
            Object.keys(customCardSets).forEach(setKey => {
                const csKey = 'custom-' + setKey;
                if (!collectionProgress[csKey]) {
                    collectionProgress[csKey] = {};
                }
            });
        }
        
        // Render set buttons with inline progress bars
        function renderSetButtons() {
            const container = document.getElementById('setButtons');
            container.innerHTML = '';

            Object.keys(cardSets).forEach(setKey => {
                const setData = cardSets[setKey];
                const btn = document.createElement('button');
                btn.className = 'set-btn' + (setKey === currentSet ? ' active' : '');
                btn.setAttribute('data-set-key', setKey);

                // Format release date nicely
                let dateStr = '';
                if (setData.releaseDate) {
                    const d = new Date(setData.releaseDate + 'T00:00:00');
                    dateStr = d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                }

                // Calculate progress for this set
                const progress = getSetProgress(setKey);

                btn.innerHTML = `
                    <div class="set-btn-left" style="flex:1;min-width:0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <span class="set-btn-name">${setData.displayName}</span>
                            <div class="set-btn-right">
                                ${setData.blockCode ? `<span class="block-badge block-${setData.blockCode}">${setData.block}</span>` : ''}
                                <span class="set-btn-stats">${progress.collected}/${progress.total} (${progress.percentage}%)</span>
                            </div>
                        </div>
                        ${dateStr ? `<span class="set-release-date">${dateStr}</span>` : ''}
                        <div class="set-btn-progress">
                            <div class="set-btn-progress-fill" style="width: ${progress.percentage}%"></div>
                        </div>
                    </div>
                `;
                btn.onclick = () => switchSet(setKey);
                container.appendChild(btn);
            });
        }

        // Calculate progress for a single set
        function getSetProgress(setKey) {
            const setData = cardSets[setKey];
            let totalVariants = 0;
            let collectedVariants = 0;

            if (setData && setData.cards) {
                setData.cards.forEach(card => {
                    const variants = getVariants(card, setKey);
                    totalVariants += variants.length;

                    const cardProgress = (collectionProgress[setKey] || {})[card.number] || {};
                    variants.forEach(variant => {
                        if (cardProgress[variant]) collectedVariants++;
                    });
                });
            }

            const percentage = totalVariants > 0 ? (collectedVariants / totalVariants * 100).toFixed(1) : '0.0';
            return { collected: collectedVariants, total: totalVariants, percentage };
        }

        // Update progress bars in set buttons without full re-render
        function updateSetButtonProgress() {
            document.querySelectorAll('.set-btn[data-set-key]').forEach(btn => {
                const setKey = btn.getAttribute('data-set-key');
                const progress = getSetProgress(setKey);
                const fill = btn.querySelector('.set-btn-progress-fill');
                const stats = btn.querySelector('.set-btn-stats');
                if (fill) fill.style.width = progress.percentage + '%';
                if (stats) stats.textContent = `${progress.collected}/${progress.total} (${progress.percentage}%)`;
            });
        }
        
        // Switch top-level tabs
        function switchTopTab(tabId) {
            // Update tab buttons
            document.querySelectorAll('.top-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.top-tab[onclick="switchTopTab('${tabId}')"]`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.top-tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabId + '-content').classList.add('active');
        }

        // Switch active set
        function switchSet(setKey) {
            currentSet = setKey;

            // Update buttons
            document.querySelectorAll('.set-btn').forEach((btn, idx) => {
                btn.classList.toggle('active', Object.keys(cardSets)[idx] === setKey);
            });

            // Update sections
            document.querySelectorAll('.set-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(setKey).classList.add('active');

            // Render cards if not already rendered
            const grid = document.getElementById(setKey + '-grid');
            if (grid && grid.children.length === 0) {
                renderCards(setKey);
            }
        }
        
        
        // Render cards for a set
        function renderCards(setKey) {
            console.log(`renderCards: ${setKey}`);
            
            const grid = document.getElementById(setKey + '-grid');
            const setData = cardSets[setKey];
            
            console.log(`Grid found: ${!!grid}, Data found: ${!!setData}`);
            
            if (!grid) {
                console.log(`ERROR: No grid for ${setKey}-grid`);
                return;
            }
            
            if (!setData) {
                console.log(`ERROR: No data for ${setKey}`);
                return;
            }
            
            grid.innerHTML = '';
            
            if (!collectionProgress[setKey]) {
                collectionProgress[setKey] = {};
            }
            
            console.log(`Rendering ${setData.cards.length} cards`);
            
            setData.cards.forEach((card, index) => {
                const variants = getVariants(card, setKey);
                const cardProgress = collectionProgress[setKey][card.number] || {};
                const allCollected = variants.every(v => cardProgress[v]);
                const isSingleVariant = variants.length === 1 && variants[0] === 'single';
                const isSecret = card.number > setData.mainSet;
                
                const cardEl = document.createElement('div');
                cardEl.className = 'card-item' + (allCollected ? ' all-collected' : '');
                cardEl.setAttribute('data-completed', allCollected ? 'true' : 'false');
                cardEl.style.cursor = 'pointer';
                cardEl.onclick = function(e) {
                    // Don't open modal if clicking on checkboxes or their containers
                    if (e.target.tagName === 'INPUT' ||
                        e.target.tagName === 'LABEL' ||
                        e.target.closest('.variant-checkbox') ||
                        e.target.closest('.single-variant')) {
                        return;
                    }
                    openCardModal(setKey, card.number);
                };

                const rarityClass = card.type === 'trainer' ? 'rarity-trainer' : `rarity-${card.rarity}`;

                // Format card number for search (e.g., "184/182") - needed for variant TCGPlayer links
                const formattedCardNumber = isSecret ? `${card.number}/${setData.mainSet}` : `${card.number}/${setData.totalCards}`;

                let variantHTML = '';
                if (isSingleVariant) {
                    const isChecked = cardProgress['single'] || false;
                    variantHTML = `
                        <div class="single-variant ${isChecked ? 'checked' : ''}" onclick="toggleVariant('${setKey}', ${card.number}, 'single')">
                            <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="event.stopPropagation(); toggleVariant('${setKey}', ${card.number}, 'single')">
                            <label>✓ Collected</label>
                        </div>
                    `;
                } else {
                    variantHTML = variants.map(variant => {
                        const isChecked = cardProgress[variant] || false;
                        const info = variantLabels[variant];
                        const variantTCGUrl = getTCGPlayerUrl(card.name, setData.name, setData.setCode, formattedCardNumber, variant);
                        return `
                            <div class="variant-checkbox ${isChecked ? 'checked' : ''}" onclick="toggleVariant('${setKey}', ${card.number}, '${variant}')">
                                <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="event.stopPropagation(); toggleVariant('${setKey}', ${card.number}, '${variant}')">
                                <label>${info.icon} ${info.label}</label>
                                <a href="${variantTCGUrl}" target="_blank" class="variant-tcgplayer-link" title="Search ${info.label} on TCGPlayer" onclick="event.stopPropagation();">
                                    <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor">
                                        <path d="M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                                    </svg>
                                </a>
                            </div>
                        `;
                    }).join('');
                    variantHTML = '<div class="variant-checkboxes">' + variantHTML + '</div>';
                }
                
                const apiImgUrl = getCardImageUrl(setKey, card.number, card.imageId);
                const tcgdexImgUrl = getTcgdexImageUrl(setKey, card.number, card.imageId);
                const localImgUrl = `Images/cards/${setKey}/${String(card.number).padStart(3, '0')}.png`;
                const primarySrc = apiImgUrl || tcgdexImgUrl || localImgUrl;
                const tcgplayerUrl = getTCGPlayerUrl(card.name, setData.name, setData.setCode, formattedCardNumber);

                cardEl.innerHTML = `
                    <div class="card-img-wrapper">
                        <img src="${primarySrc}"
                             alt="${card.name.replace(/"/g, '&quot;')}"
                             loading="lazy"
                             ${tcgdexImgUrl ? `data-tcgdex-src="${tcgdexImgUrl}"` : ''}
                             data-local-src="${localImgUrl}"
                             data-card-name="${card.name.replace(/"/g, '&quot;')}"
                             data-card-number="${card.number}"
                             data-card-rarity="${card.rarity}"
                             onerror="handleImgError(this)">
                    </div>
                    <div class="card-header">
                        <div class="card-info">
                            <div class="card-number">#${String(card.number).padStart(3, '0')}${isSecret ? ` / ${setData.mainSet}` : ''}</div>
                            <div class="card-name">${card.name}</div>
                            <span class="rarity-badge ${rarityClass}">${card.type === 'trainer' ? 'TRAINER' : getRarityDisplay(card.rarity)}</span>
                        </div>
                        <a href="${tcgplayerUrl}" target="_blank" class="tcgplayer-link" title="View on TCGPlayer" onclick="event.stopPropagation();">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                <path d="M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                            </svg>
                        </a>
                    </div>
                    <div class="variants-section">
                        <div class="variants-title">${isSingleVariant ? 'STATUS:' : 'VARIANTS:'}</div>
                        ${variantHTML}
                        ${allCollected ? `<div class="completed-lock"><svg viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2z"/></svg>Complete</div>` : ''}
                    </div>
                `;
                
                grid.appendChild(cardEl);
            });

            console.log(`✓ Done: ${grid.children.length} cards in grid`);

            // Reapply active filters and search after rendering
            applyFiltersAndSearch(setKey);
        }

        // Store active filters and searches for each set
        let activeFilters = {};
        let activeSearches = {};

        // Filter cards by completion status
        window.filterCards = function(setKey, filterType) {
            // Update active filter
            activeFilters[setKey] = filterType;

            // Update button states
            const section = document.getElementById(setKey);
            if (section) {
                const buttons = section.querySelectorAll('.filter-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if ((filterType === 'all' && btn.textContent === 'All') ||
                        (filterType === 'incomplete' && btn.textContent === 'Incomplete') ||
                        (filterType === 'complete' && btn.textContent === 'Complete')) {
                        btn.classList.add('active');
                    }
                });
            }

            // Apply filter to cards
            applyFiltersAndSearch(setKey);
        };

        // Search cards by name or number
        window.searchCards = function(setKey, query) {
            activeSearches[setKey] = query.toLowerCase().trim();

            // Show/hide clear button
            const section = document.getElementById(setKey);
            if (section) {
                const clearBtn = section.querySelector('.search-clear');
                if (clearBtn) {
                    if (query.trim()) {
                        clearBtn.classList.add('visible');
                    } else {
                        clearBtn.classList.remove('visible');
                    }
                }
            }

            // Apply search to cards
            applyFiltersAndSearch(setKey);
        };

        // Clear search input
        window.clearSearch = function(setKey) {
            const section = document.getElementById(setKey);
            if (section) {
                const searchInput = section.querySelector('.search-input');
                if (searchInput) {
                    searchInput.value = '';
                }
                const clearBtn = section.querySelector('.search-clear');
                if (clearBtn) {
                    clearBtn.classList.remove('visible');
                }
            }
            activeSearches[setKey] = '';
            applyFiltersAndSearch(setKey);
        };

        // Apply both filters and search to cards
        function applyFiltersAndSearch(setKey) {
            const grid = document.getElementById(setKey + '-grid');
            if (!grid) return;

            const filterType = activeFilters[setKey] || 'all';
            const searchQuery = activeSearches[setKey] || '';

            const cards = grid.querySelectorAll('.card-item');
            cards.forEach(card => {
                let show = true;

                // Apply filter
                const isCompleted = card.getAttribute('data-completed') === 'true';
                if (filterType === 'incomplete' && isCompleted) {
                    show = false;
                } else if (filterType === 'complete' && !isCompleted) {
                    show = false;
                }

                // Apply search
                if (show && searchQuery) {
                    const cardName = card.querySelector('.card-name')?.textContent.toLowerCase() || '';
                    const cardNumber = card.querySelector('.card-number')?.textContent.toLowerCase() || '';

                    if (!cardName.includes(searchQuery) && !cardNumber.includes(searchQuery)) {
                        show = false;
                    }
                }

                // Show or hide card
                card.style.display = show ? '' : 'none';
            });
        }

        // Card Detail Modal Functions
        window.openCardModal = function(setKey, cardNumber) {
            let setData, card, variants, setName;

            // Get card data based on set type
            if (setKey.startsWith('custom-')) {
                const customKey = setKey.replace('custom-', '');
                setData = customCardSets[customKey];
                card = setData ? setData.cards.find(c => c.number === cardNumber) : null;
                variants = card ? getCustomCardVariants(card) : ['single'];
                setName = card && card.setOrigin ? card.setOrigin : (setData ? setData.name : '');
            } else {
                setData = cardSets[setKey];
                card = setData ? setData.cards.find(c => c.number === cardNumber) : null;
                variants = card ? getVariants(card, setKey) : [];
                setName = setData ? setData.name : '';
            }

            if (!card) return;

            // Get modal elements
            const modal = document.getElementById('cardModal');
            const modalImage = document.getElementById('modalCardImage');
            const modalName = document.getElementById('modalCardName');
            const modalNumber = document.getElementById('modalCardNumber');
            const modalSet = document.getElementById('modalCardSet');
            const modalRarity = document.getElementById('modalCardRarity');
            const modalTCGPlayerLink = document.getElementById('modalTCGPlayerLink');
            const modalVariantsTitle = document.getElementById('modalVariantsTitle');
            const modalVariantList = document.getElementById('modalVariantList');

            // Set card image
            let primarySrc;
            if (setKey.startsWith('custom-')) {
                // For custom sets, use the custom card image URL function
                primarySrc = getCustomCardImageUrl(card);
            } else {
                // For regular sets, use the standard image URL logic
                const apiImgUrl = getCardImageUrl(setKey, card.number, card.imageId);
                const tcgdexImgUrl = getTcgdexImageUrl(setKey, card.number, card.imageId);
                const localImgUrl = `Images/cards/${setKey}/${String(card.number).padStart(3, '0')}.png`;
                primarySrc = apiImgUrl || tcgdexImgUrl || localImgUrl;
            }
            modalImage.src = primarySrc || '';
            modalImage.alt = card.name;

            // Set card details
            modalName.textContent = card.name;

            // Display card number (use originalNumber for custom sets)
            let displayNumber;
            if (setKey.startsWith('custom-')) {
                displayNumber = card.originalNumber ? card.originalNumber : String(card.number).padStart(3, '0');
                modalNumber.textContent = `#${displayNumber}${card.region === 'JP' ? ' (JP)' : ''}`;
            } else {
                const isSecret = card.number > setData.mainSet;
                displayNumber = String(card.number).padStart(3, '0');
                modalNumber.textContent = `#${displayNumber}${isSecret ? ` / ${setData.mainSet}` : ''}`;
            }

            modalSet.textContent = `Set: ${setName}`;

            // Set rarity badge
            const rarityClass = card.type === 'trainer' ? 'rarity-trainer' : `rarity-${card.rarity}`;
            modalRarity.className = 'card-modal-rarity ' + rarityClass;
            modalRarity.textContent = card.type === 'trainer' ? 'TRAINER' : getRarityDisplay(card.rarity);

            // Set TCGPlayer link
            if (setKey.startsWith('custom-')) {
                // For custom sets, use the card's setOrigin
                const customCardNumber = card.originalNumber || null;
                const tcgplayerUrl = getTCGPlayerUrl(card.name, card.setOrigin || 'Pokemon', '', customCardNumber);
                modalTCGPlayerLink.href = tcgplayerUrl;
                modalTCGPlayerLink.style.display = 'inline-block';
            } else if (setData && setData.setCode) {
                // For regular sets, use the setCode with formatted card number
                const isSecret = card.number > setData.mainSet;
                const formattedCardNumber = isSecret ? `${card.number}/${setData.mainSet}` : `${card.number}/${setData.totalCards}`;
                const tcgplayerUrl = getTCGPlayerUrl(card.name, setName, setData.setCode, formattedCardNumber);
                modalTCGPlayerLink.href = tcgplayerUrl;
                modalTCGPlayerLink.style.display = 'inline-block';
            } else {
                // Hide link if no set information is available
                modalTCGPlayerLink.style.display = 'none';
            }

            // Set variants
            const isSingleVariant = variants.length === 1 && variants[0] === 'single';
            modalVariantsTitle.textContent = isSingleVariant ? 'Collection Status:' : 'Variants:';

            // Build variant list
            const cardProgress = collectionProgress[setKey] ? collectionProgress[setKey][cardNumber] || {} : {};
            modalVariantList.innerHTML = '';

            if (isSingleVariant) {
                const isChecked = cardProgress['single'] || false;
                const variantItem = document.createElement('div');
                variantItem.className = 'card-modal-variant-item' + (isChecked ? ' collected' : '');
                variantItem.innerHTML = `
                    <input type="checkbox" class="card-modal-variant-checkbox" ${isChecked ? 'checked' : ''}
                           onchange="toggleVariantFromModal('${setKey}', ${cardNumber}, 'single')">
                    <label>✓ Collected</label>
                `;
                modalVariantList.appendChild(variantItem);
            } else {
                // Handle multiple variants
                if (setKey.startsWith('custom-') && card.variants && card.variants.length > 0) {
                    // Custom set with multiple variants
                    card.variants.forEach(v => {
                        const isChecked = cardProgress[v.rarity] || false;
                        const displayNum = v.originalNumber ? ` #${v.originalNumber}` : '';
                        const variantItem = document.createElement('div');
                        variantItem.className = 'card-modal-variant-item' + (isChecked ? ' collected' : '');
                        variantItem.innerHTML = `
                            <input type="checkbox" class="card-modal-variant-checkbox" ${isChecked ? 'checked' : ''}
                                   onchange="toggleVariantFromModal('${setKey}', ${cardNumber}, '${v.rarity}')">
                            <label>${getRarityDisplay(v.rarity)}${displayNum}</label>
                        `;
                        modalVariantList.appendChild(variantItem);
                    });
                } else {
                    // Regular set variants
                    variants.forEach(variant => {
                        const isChecked = cardProgress[variant] || false;
                        const info = variantLabels[variant];
                        const variantItem = document.createElement('div');
                        variantItem.className = 'card-modal-variant-item' + (isChecked ? ' collected' : '');
                        variantItem.innerHTML = `
                            <input type="checkbox" class="card-modal-variant-checkbox" ${isChecked ? 'checked' : ''}
                                   onchange="toggleVariantFromModal('${setKey}', ${cardNumber}, '${variant}')">
                            <label>${info.icon} ${info.label}</label>
                        `;
                        modalVariantList.appendChild(variantItem);
                    });
                }
            }

            // Show modal
            modal.classList.add('visible');
        };

        window.closeCardModal = function() {
            const modal = document.getElementById('cardModal');
            modal.classList.remove('visible');
        };

        // Toggle variant from modal
        window.toggleVariantFromModal = function(setKey, cardNumber, variant) {
            // Use the existing toggleVariant function
            toggleVariant(setKey, cardNumber, variant);

            // Update the modal display after a brief delay to allow re-render
            setTimeout(() => {
                openCardModal(setKey, cardNumber);
            }, 50);
        };

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('cardModal');
            if (e.target === modal) {
                closeCardModal();
            }
        });

        // Close modal with ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeCardModal();
            }
        });

        // Toggle variant (with soft-lock protection for completed cards)
        window.toggleVariant = function(setKey, cardNumber, variant) {
            if (!collectionProgress[setKey]) {
                collectionProgress[setKey] = {};
            }
            if (!collectionProgress[setKey][cardNumber]) {
                collectionProgress[setKey][cardNumber] = {};
            }

            const isCurrentlyChecked = collectionProgress[setKey][cardNumber][variant] || false;

            // If unchecking a variant on a fully-completed card, show confirmation
            if (isCurrentlyChecked) {
                let setData, card, variants;
                if (setKey.startsWith('custom-')) {
                    const customKey = setKey.replace('custom-', '');
                    setData = customCardSets[customKey];
                    card = setData ? setData.cards.find(c => c.number === cardNumber) : null;
                    variants = card ? getCustomCardVariants(card) : ['single'];
                } else {
                    setData = cardSets[setKey];
                    card = setData ? setData.cards.find(c => c.number === cardNumber) : null;
                    variants = card ? getVariants(card, setKey) : [];
                }
                if (card) {
                    const cardProgress = collectionProgress[setKey][cardNumber] || {};
                    const allCollected = variants.every(v => cardProgress[v]);

                    if (allCollected) {
                        showUnlockConfirmation(setKey, cardNumber, variant, card.name);
                        return;
                    }
                }
            }

            applyVariantToggle(setKey, cardNumber, variant);
        };

        // Actually apply the toggle (called directly or after confirmation)
        function applyVariantToggle(setKey, cardNumber, variant) {
            if (!collectionProgress[setKey]) {
                collectionProgress[setKey] = {};
            }
            if (!collectionProgress[setKey][cardNumber]) {
                collectionProgress[setKey][cardNumber] = {};
            }

            collectionProgress[setKey][cardNumber][variant] = !collectionProgress[setKey][cardNumber][variant];

            // Save to localStorage
            localStorage.setItem('pokemonVariantProgress', JSON.stringify(collectionProgress));

            // Save to Firebase
            if (firebase_ref) {
                firebase_ref.set(collectionProgress);
            }

            // Re-render
            if (setKey.startsWith('custom-')) {
                const customKey = setKey.replace('custom-', '');
                renderCustomCards(customKey);
                updateCustomSetButtonProgress();
            } else {
                renderCards(setKey);
                updateSetButtonProgress();
            }
        }

        // Show unlock confirmation toast
        let activeToast = null;
        function showUnlockConfirmation(setKey, cardNumber, variant, cardName) {
            // Remove any existing toast
            if (activeToast) {
                activeToast.remove();
                activeToast = null;
            }

            const toast = document.createElement('div');
            toast.className = 'unlock-toast';
            const variantInfo = variantLabels[variant];
            const variantName = variantInfo ? variantInfo.label : (RARITY_DISPLAY_NAMES[variant] || variant);
            toast.innerHTML = `
                <div class="unlock-toast-text">
                    Uncheck <strong>${variantName}</strong> on <strong>${cardName}</strong>? This card is complete.
                </div>
                <div class="unlock-toast-buttons">
                    <button class="unlock-toast-btn cancel" id="toastCancel">Keep</button>
                    <button class="unlock-toast-btn confirm" id="toastConfirm">Uncheck</button>
                </div>
            `;
            document.body.appendChild(toast);
            activeToast = toast;

            // Animate in
            requestAnimationFrame(() => toast.classList.add('visible'));

            // Wire up buttons
            document.getElementById('toastConfirm').onclick = () => {
                toast.classList.remove('visible');
                setTimeout(() => { toast.remove(); activeToast = null; }, 300);
                applyVariantToggle(setKey, cardNumber, variant);
            };
            const reRender = () => {
                if (setKey.startsWith('custom-')) {
                    renderCustomCards(setKey.replace('custom-', ''));
                } else {
                    renderCards(setKey);
                }
            };

            document.getElementById('toastCancel').onclick = () => {
                toast.classList.remove('visible');
                setTimeout(() => { toast.remove(); activeToast = null; }, 300);
                // Re-render to restore the checkbox the browser already toggled visually
                reRender();
            };

            // Auto-dismiss after 5 seconds (treat as "Keep")
            setTimeout(() => {
                if (activeToast === toast) {
                    toast.classList.remove('visible');
                    setTimeout(() => { toast.remove(); activeToast = null; }, 300);
                    // Re-render to restore the checkbox the browser already toggled visually
                    reRender();
                }
            }, 5000);
        }
        
        // Update sync status
        function updateSyncStatus(text, status) {
            document.getElementById('syncStatus').textContent = text;
            const indicator = document.getElementById('syncIndicator');
            indicator.className = 'sync-indicator ' + status;
        }
        
        // Show sync code modal
        function showSyncModal() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-title">🔐 Enter Sync Code</div>
                    <div class="modal-text">Enter your family sync code to enable cloud synchronization across devices.</div>
                    <input type="text" class="modal-input" id="syncCodeInput" placeholder="Enter sync code..." autocomplete="off">
                    <div class="error-text" id="syncError"></div>
                    <div class="modal-buttons">
                        <button class="modal-btn primary" onclick="verifySyncCode()">Sync</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            document.getElementById('syncCodeInput').focus();
            document.getElementById('syncCodeInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') verifySyncCode();
            });
        }
        
        // Verify sync code
        window.verifySyncCode = function() {
            console.log('verifySyncCode called');
            const input = document.getElementById('syncCodeInput');
            const code = input.value.trim();
            
            console.log(`Code entered: "${code}"`);
            console.log(`Expected: "${SYNC_CODE}"`);
            
            if (code === SYNC_CODE) {
                console.log('✓ Code valid!');
                localStorage.setItem(SYNC_CODE_KEY, code);
                document.querySelector('.modal').remove();
                
                // Render cards immediately BEFORE Firebase
                console.log('Rendering cards now...');
                Object.keys(cardSets).forEach(setKey => {
                    console.log(`Calling renderCards(${setKey})`);
                    renderCards(setKey);
                });
                updateSetButtonProgress();
                
                console.log('Starting Firebase...');
                // Then initialize Firebase
                initializeFirebase();
            } else {
                console.log('✗ Invalid code');
                document.getElementById('syncError').textContent = 'Invalid sync code. Please try again.';
                input.value = '';
            }
        };
        
        // Initialize Firebase
        function initializeFirebase() {
            try {
                const config = {
                    apiKey: "AIzaSyDUZwwGKYfRzvj13bKTkYecIH19ge8oWZw",
                    authDomain: "blair-pokemon-tracker.firebaseapp.com",
                    databaseURL: "https://blair-pokemon-tracker-default-rtdb.firebaseio.com",
                    projectId: "blair-pokemon-tracker",
                    storageBucket: "blair-pokemon-tracker.firebasestorage.app",
                    messagingSenderId: "169585887164",
                    appId: "1:169585887164:web:16d3ff0705153848df8db9"
                };
                
                if (!firebase.apps.length) {
                    firebase.initializeApp(config);
                }
                
                firebase_db = firebase.database();
                firebase_ref = firebase_db.ref('collections/' + SYNC_CODE);
                
                updateSyncStatus('Connecting...', 'syncing');
                
                firebase_ref.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        collectionProgress = data;
                        localStorage.setItem('pokemonVariantProgress', JSON.stringify(data));
                        
                        // Re-render all sets with synced data
                        Object.keys(cardSets).forEach(setKey => {
                            renderCards(setKey);
                        });
                        updateSetButtonProgress();
                        Object.keys(customCardSets).forEach(setKey => {
                            renderCustomCards(setKey);
                        });
                        updateCustomSetButtonProgress();

                        updateSyncStatus('Synced ✓', 'synced');
                    } else {
                        // No data yet, upload current progress and render cards
                        firebase_ref.set(collectionProgress);

                        // Ensure cards are rendered even if no Firebase data
                        Object.keys(cardSets).forEach(setKey => {
                            renderCards(setKey);
                        });
                        updateSetButtonProgress();
                        Object.keys(customCardSets).forEach(setKey => {
                            renderCustomCards(setKey);
                        });
                        updateCustomSetButtonProgress();

                        updateSyncStatus('Synced ✓', 'synced');
                    }
                });

            } catch (error) {
                console.error('Firebase error:', error);
                updateSyncStatus('Offline', 'error');

                // CRITICAL: Render cards even if Firebase fails
                Object.keys(cardSets).forEach(setKey => {
                    renderCards(setKey);
                });
                updateSetButtonProgress();
                Object.keys(customCardSets).forEach(setKey => {
                    renderCustomCards(setKey);
                });
                updateCustomSetButtonProgress();
            }
        }
        
        // Initialize app
        window.addEventListener('load', async function() {
            try {
                console.log('App loading...');
                
                // Load card data
                const loaded = await loadCardData();
                if (!loaded) {
                    console.log('Failed to load data!');
                    return;
                }

                // Load custom sets data
                await loadCustomSetsData();

                console.log('Initializing progress...');
                // Initialize progress
                initializeProgress();

                console.log('Rendering UI...');

                console.log('Calling renderSetButtons...');
                try {
                    renderSetButtons();
                    console.log('✓ Set buttons rendered');
                } catch (e) {
                    console.log('ERROR in renderSetButtons: ' + e.message);
                }

                console.log('Calling updateSetButtonProgress...');
                try {
                    updateSetButtonProgress();
                    console.log('✓ Progress rendered');
                } catch (e) {
                    console.log('ERROR in updateSetButtonProgress: ' + e.message);
                }

                // Cards are now rendered on-demand when user selects a set
                console.log('Card grids ready - cards will render when sets are selected');

                // Initialize custom set grids and buttons
                console.log('Initializing custom sets...');
                try {
                    initCustomSetGrids();
                    renderCustomSetButtons();
                    // Custom set cards will render on-demand when user selects a set
                    console.log('✓ Custom set grids and buttons ready');
                } catch (e) {
                    console.log('ERROR in custom sets: ' + e.message);
                }
                
                console.log('Checking sync code...');
                // Check for sync code
                const savedCode = localStorage.getItem(SYNC_CODE_KEY);
                if (savedCode === SYNC_CODE) {
                    console.log('Saved code found, initializing Firebase');
                    initializeFirebase();
                } else {
                    console.log('No saved code, showing modal');
                    showSyncModal();
                }
            } catch (error) {
                console.log('FATAL ERROR: ' + error.message);
                console.error('Fatal error:', error);
            }
        });
    </script>

    <!-- Card Detail Modal -->
    <div id="cardModal" class="card-modal">
        <div class="card-modal-content">
            <button class="card-modal-close" onclick="closeCardModal()">×</button>
            <div class="card-modal-body">
                <div class="card-modal-image">
                    <img id="modalCardImage" src="" alt="">
                </div>
                <div class="card-modal-details">
                    <div>
                        <div class="card-modal-title" id="modalCardName"></div>
                        <div class="card-modal-number" id="modalCardNumber"></div>
                        <div class="card-modal-set" id="modalCardSet"></div>
                        <div class="card-modal-rarity" id="modalCardRarity"></div>
                        <a id="modalTCGPlayerLink" href="#" target="_blank" class="tcgplayer-modal-link" style="display: inline-block; margin-top: 8px; padding: 6px 12px; background: #2563eb; color: white; text-decoration: none; border-radius: 4px; font-size: 14px;">
                            View on TCGPlayer
                        </a>
                    </div>
                    <div class="card-modal-variants">
                        <div class="card-modal-variants-title" id="modalVariantsTitle">Variants:</div>
                        <div class="card-modal-variant-list" id="modalVariantList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
